#!/usr/bin/python3

import argparse
from utilities.colors import color
from utilities.tools import clear

# function to modify the given key if key length is less than the message
def generate_FinalKey(text,key):
    finalkey = ''
    key = key.replace(' ', '')      # key should not contain spaces

    # key length is longer than original message
    # cut the key upto the message length
    if len(key)>len(text):
        finalkey = key[:len(text)]

    # key length is lesser than message size
    # repeat the key upto the size of the message
    # (this process excludes everything except alphabets in the message)
    elif len(key)<len(text):
        finalkey = (key * (int(len(text)/len(key))+1)) [:len(text)]                 # generate key for all characters of message (alphanumeric)

        for c in range(len(text)):                                                # traverses the length of the original message            
            if not text[c].isalpha():                                             # checks if the character is not an alphabet
                finalkey = finalkey[:c] + text[c] + finalkey[c:len(finalkey)-1]   # replaces key alphabets with the exact special character
    else:
        finalkey=key

    return finalkey

# encryption function 
# takes in the plaintext and key to encrypt with
# and returns the encrpyted ciphertext
def encrypt(plain,key):
    
    plain_bak = plain
    plain=''
    for p in plain_bak:
        if p.isalpha():
            plain+=p
    # send for generation of key of correct length    
    key = generate_FinalKey(plain, key)

    # check if key contains numbers (not allowed)
    for ch in key:
        if ch.isdigit():
            print('{}[-]{} Key should only contain Alphabets!\n{}[!] Quitting...{}'.format(color.RED,color.END,color.RED,color.END))
            quit()

    plainASCII = [ord(char) for char in plain]          # ASCII list of plaintext
    keyASCII = [ord(char) for char in key]              # ASCII list of given key
    cipherASCII = []

    # traverse the length of the plaintext message
    for i in range(len(plain)):
        # check if plaintext character is an alphabet
        if plain[i].isalpha():
            for x in range(26):
                for y in range(26):
                    s=x+y
                    # check if the plaintext character and key character indices match 
                    # according to the Vigenere matrix generated by the loops
                    if chr(x+97)==chr(plainASCII[i]).lower() and chr(y+97)==chr(keyASCII[i]).lower():
                        if chr(plainASCII[i]).isupper():        # if original character was uppercase
                            cipherASCII.append(s%26+65)         # append the uppercase counterpart of the character
                            #print(chr(s%26+65),end='')
                        else:                                   # for lowercase plaintext
                            cipherASCII.append(s%26+97)         # append the lowercase ciphertext character
                            #print(chr(s%26+97),end='')
        
        # if plaintext character is not alphabet (numbers, special characters are out of scope)
        else:
            cipherASCII.append(plainASCII[i])                   # append the original non-alpha character to the ciphertext
            #print(chr(plainASCII[i]),end='')
    
    # create ciphertext string from ASCII list
    cipher = ''.join(map(chr,cipherASCII))
    # add special characters to final text
    for i in range(len(plain_bak)): 
        if not plain_bak[i].isalpha():
            cipher = cipher[:i] + plain_bak[i] + cipher[i:]
    return cipher

###################################################################################################

# decryption function 
# takes in the ciphertext and key used to encrypt
# and returns the decrpyted plaintext
def decrypt(cipher,key):
    
    # send for generation of key of correct length    
    cipher_bak = cipher
    cipher=''
    for c in cipher_bak:
        if c.isalpha():
            cipher+=c
    key = generate_FinalKey(cipher, key)

    # check if key contains numbers (not allowed)
    for ch in key:
        if ch.isdigit():
            print('{}[-]{} Key should only contain Alphabets!\n{}[!] Quitting...{}'.format(color.RED,color.END,color.RED,color.END))
            quit()

    cipherASCII = [ord(char) for char in cipher]     # ASCII list of ciphertext
    keyASCII = [ord(char) for char in key]          # ASCII list of given key
    plainASCII = []

    # traverse the length of the plaintext message
    for i in range(len(cipher)):
        # check if plaintext character is an alphabet
        if cipher[i].isalpha():
            for x in range(26):
                for y in range(26):
                    s=x+y
                    # check if the plaintext character and key character indices match 
                    # according to the Vigenere matrix generated by the loops
                    if chr(s%26+97)==chr(cipherASCII[i]).lower() and chr(y+97)==chr(keyASCII[i]).lower():
                        if chr(cipherASCII[i]).isupper():        # if original character was uppercase
                            plainASCII.append(x+65)         # append the uppercase counterpart of the character
                            #print(chr(s%26+65),end='')
                        else:                                   # for lowercase plaintext
                            plainASCII.append(x+97)         # append the lowercase ciphertext character
                            #print(chr(s%26+97),end='')
        
        # if plaintext character is not alphabet (numbers, special characters are out of scope)
        else:
            plainASCII.append(cipherASCII[i])                   # append the original non-alpha character to the ciphertext
            #print(chr(plainASCII[i]),end='')
    
    # create ciphertext string from ASCII list
    plain = ''.join(map(chr,plainASCII))
    # add special characters to final text
    for i in range(len(cipher_bak)):
        if not cipher_bak[i].isalpha():
            plain = plain[:i] + cipher_bak[i] + plain[i:]
    return plain


def parsefile(filename):
    message = ''
    with open(filename) as f:
        for line in f:
            message+=line
    return message


###################################################################################################


def run():
    try:
        clear()
        choice = input('{}[?]{} Encrypt or Decrypt? [e/d] : '.format(color.BLUE,color.END))
        if choice == 'e' or choice == 'E':
            # whether to load a file for the plaintext or type it from the console
            filechoice = 'n'
            filechoice = input('{}[?]{} Load from a file? [y/N] : '.format(color.BLUE,color.END)).lower()
            if filechoice != 'y':
                pt = input('{}[?]{} Enter the Plaintext message to encrypt: '.format(color.BLUE,color.END))
            else:
                filename = input('{}[?]{} Enter the filename: '.format(color.BLUE,color.END))
                pt = parsefile(filename)
            key = input('{}[?]{} Enter the Key to encrypt the message: '.format(color.BLUE,color.END))
            if not key:
                print('{}[-] Please provide a valid Key to encrypt the message{}'.format(color.RED,color.END))
                quit()
            ciphertext = encrypt(pt, key)
            print('{}[+] The Ciphertext with Key = {}{}{} is: {}{}{}'.format(color.GREEN,color.YELLOW,key,color.GREEN,color.RED,ciphertext,color.END))
        elif choice == 'd' or choice == 'D':
            # whether to load a file for the plaintext or type it from the console
            filechoice = 'n'
            filechoice = input('{}[?]{} Load from a file? [y/N] : '.format(color.BLUE,color.END)).lower()
            if filechoice != 'y':
                ct = input('{}[?]{} Enter the Ciphertext message to decrypt: '.format(color.BLUE,color.END))
            else:
                filename = input('{}[?]{} Enter the filename: '.format(color.BLUE,color.END))
                ct = parsefile(filename)
            key = input('{}[?]{} Enter the Key to encrypt the message: '.format(color.BLUE,color.END))
            if not key:
                print('{}[-] Please provide a valid Key to decrypt the message{}'.format(color.RED,color.END))
                quit()
            plaintext = decrypt(ct, key)
            print('{}[+] The Plaintext with Key = {}{}{} is : {}{}{}'.format(color.GREEN,color.YELLOW,key,color.GREEN,color.RED,plaintext,color.END))
        else:
            print('{}[-] Please provide a valid coice of action{}'.format(color.RED,color.END))
        quit()
    except KeyboardInterrupt:
        print('\n{}[!] Exiting...{}'.format(color.RED,color.END))


def main():

    try:
        clear()

        # script description
        parser = argparse.ArgumentParser(description='Vigenere Cipher Encryption & Decryption')
        # encryption group option (single option --encrypt)
        enc_group = parser.add_argument_group('Encryption Options')
        enc_group.add_argument('-e','--encrypt', help='Encrypt a given Plaintext', default=False, action='store_true')
        # decryption group options (--decrypt and --brute)
        dec_group = parser.add_argument_group('Decryption Options')
        dec_group.add_argument('-d','--decrypt', help='Decrypt a given Ciphertext', default=False, action='store_true')    
        # file option - whether to load from a file
        parser.add_argument('-f','--file', help='Load the Plaintext/ Ciphertext from a file', default=False, action='store_true')
        # message (either plain or cipher)  -   handled later on based on options
        parser.add_argument('TEXT', help='Plaintext or Ciphertext (based on mode)')
        parser.add_argument('KEY', help='Key used for encryption/ decryption')

        try:
            args = parser.parse_args()
        except:
            choice = input('{}[?]{} Encrypt or Decrypt? [e/d] : '.format(color.BLUE,color.END))
            if choice == 'e' or choice == 'E':
                # whether to load a file for the plaintext or type it from the console
                filechoice = 'n'
                filechoice = input('{}[?]{} Load from a file? [y/N] : '.format(color.BLUE,color.END)).lower()
                if filechoice != 'y':
                    pt = input('{}[?]{} Enter the Plaintext message to encrypt: '.format(color.BLUE,color.END))
                else:
                    filename = input('{}[?]{} Enter the filename: '.format(color.BLUE,color.END))
                    pt = parsefile(filename)
                key = input('{}[?]{} Enter the Key to encrypt the message: '.format(color.BLUE,color.END))
                if not key:
                    print('{}[-] Please provide a valid Key to encrypt the message{}'.format(color.RED,color.END))
                    quit()
                ciphertext = encrypt(pt, key)
                print('{}[+] The Ciphertext with Key = {}{}{} is: {}{}{}'.format(color.GREEN,color.YELLOW,key,color.GREEN,color.RED,ciphertext,color.END))
            elif choice == 'd' or choice == 'D':
                # whether to load a file for the plaintext or type it from the console
                filechoice = 'n'
                filechoice = input('{}[?]{} Load from a file? [y/N] : '.format(color.BLUE,color.END)).lower()
                if filechoice != 'y':
                    ct = input('{}[?]{} Enter the Ciphertext message to decrypt: '.format(color.BLUE,color.END))
                else:
                    filename = input('{}[?]{} Enter the filename: '.format(color.BLUE,color.END))
                    ct = parsefile(filename)
                key = input('{}[?]{} Enter the Key to decrypt the message: '.format(color.BLUE,color.END))
                if not key:
                    print('{}[-] Please provide a valid Key to decrypt the message{}'.format(color.RED,color.END))
                    quit()
                plaintext = decrypt(ct, key)
                print('{}[+] The Plaintext with Key = {}{}{} is : {}{}{}'.format(color.GREEN,color.YELLOW,key,color.GREEN,color.RED,plaintext,color.END))
            else:
                print('{}[-] Please provide a valid coice of action{}'.format(color.RED,color.END))
            quit()

        if args.encrypt:                            # if encrypt flag is on
            if args.decrypt:                        # decrypt flag should be off
                print('{}[-] Please select only one option among Encrypt or Decrypt at a time{}'.format(color.RED,color.END))
                quit()        
            else:
                if args.file:
                    pt = parsefile(args.TEXT)
                    ciphertext = encrypt(pt,args.KEY)
                else:
                    ciphertext = encrypt(args.TEXT,args.KEY)
                print('{}[+] The Ciphertext with Key = {}{}{} is : {}{}{}'.format(color.GREEN,color.YELLOW,args.KEY,color.GREEN,color.RED,ciphertext,color.END))

        elif args.decrypt:                          # if decrypt flag is on
            if args.file:
                ct = parsefile(args.TEXT)
                plaintext = decrypt(ct,args.KEY)
            else:
                plaintext = decrypt(args.TEXT,args.KEY)
            print('{}[+] The Plaintext with Key = {}{}{} is : {}{}{}'.format(color.GREEN,color.YELLOW,args.KEY,color.GREEN,color.RED,plaintext,color.END))

        # if no arguments are provided except for positional (TEXT)
        else:
            print('{}[-] At least one of Encryption or Decryption action is required{}'.format(color.RED,color.END))
    
    except KeyboardInterrupt:
        print('\n{}[!] Exiting...{}'.format(color.RED,color.END))
        quit()

if __name__ == '__main__':
    main()

